# Pros

* 任意のテクノロジーと任意のチームで開発可能
* 特定の機能をエンドツーエンド(バック、フロント、デプロイ）で確実に実行できる
* 依存関係をへらす
* 特定のドメインについて最高の知識を持つチーム間で作業を分散すると、リリースプロセスが確実にスピードアップして簡素化される

※　https://medium.com/swlh/luigi-micro-fronteds-orchestrator-8c0eca710151

* マイクロフロントエンドには独自のエラー範囲、デバッグ、および別個のコードベースがあるため、コードの保守性と共通コンポーネントの共有が向上します。
* フロントエンドとリリースが小さいということは、リグレッションテストの表面がはるかに小さいことを意味します。リリースごとの変更は少なく、理論的にはテストに費やす時間を短縮できます。

※ https://medium.com/swlh/micro-frontends-in-action-221d4ed81c35

* フロントエンドのアップグレード/変更にはコストが小さくなる
* クロステクノロジーチームを超えたクロスファンクショナル

※ https://levelup.gitconnected.com/micro-frontend-curry-506b98a4cfc0

# Cons

* 重複作業の発生

* マイクロフロントエンドは、独立したチームの自律性を向上させますが、相互接続されたチームには多くを提供しません。開発チームが小さすぎる、ドメインが相互に関連しすぎている、または受信作業が事業部門間で均等に分割されていない可能性があります。マイクロフロントエンドを使用しますが、チームにバインドされたサービスとドメインがないと、分散モノリスを構築してしまう可能性があります。アーキテクチャは薄く広がりますが、チームはそうではありません。
* フロントエンドにはすべて、より大きな機能の部分的な実装が含まれているため、個別にリリースすることはできません。
* マイクロフロントエンド間でリンクを発生させることができます。これらのリンクにより、各フロントエンドの独立性が低下し、各リリースに多くの依存関係が生じます。
* くの機能で複数のマイクロフロントエンドにまたがる変更が必要になりました。これらの分割により、各フロントエンドの独立性と自律性がなくなりました。
* 個別のアプリケーション、言語、フレームワーク間で状態を渡す必要があります。前後のワークフロー、分岐パス、ユーザーがキャンセルまたは終了できるさまざまな場所を考慮する必要があります
* イブラリを共有すること自体は問題ではありませんが、不適切な分割によって作成された任意の境界を回避するための包括的な場所として使用すると、問題が発生します。
* 検出可能性が低下した結果、一部の標準コンポーネントを共有できず、個別のフロントエンド間で実装が重複してしまいました。
* コンポーネント間の通信の構築は、実装と維持が困難であるだけでなく、コンポーネントの独立性を取り除きます。
* 横断的関心事への変更ですべてのマイクロフロントエンドを最新の状態に保つだけでは、テレメトリ、エラーロギング、パイプラインの構築に時間を費やしてしまいます
* 共有キャッシュがないと、各Webビューは独自のデータセットをプルダウンする必要があり、大量の重複呼び出しが発生しました。

※ https://medium.com/swlh/problems-with-micro-frontends-8a8fc32a7d58
