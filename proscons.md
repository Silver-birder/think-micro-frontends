# Pros

* 任意のテクノロジーと任意のチームで開発可能
* 特定の機能をエンドツーエンド(バック、フロント、デプロイ）で確実に実行できる
* 依存関係をへらす
* 特定のドメインについて最高の知識を持つチーム間で作業を分散すると、リリースプロセスが確実にスピードアップして簡素化される

※　https://medium.com/swlh/luigi-micro-fronteds-orchestrator-8c0eca710151

* マイクロフロントエンドには独自のエラー範囲、デバッグ、および別個のコードベースがあるため、コードの保守性と共通コンポーネントの共有が向上します。
* フロントエンドとリリースが小さいということは、リグレッションテストの表面がはるかに小さいことを意味します。リリースごとの変更は少なく、理論的にはテストに費やす時間を短縮できます。

※ https://medium.com/swlh/micro-frontends-in-action-221d4ed81c35

* フロントエンドのアップグレード/変更にはコストが小さくなる
* クロステクノロジーチームを超えたクロスファンクショナル

※ https://levelup.gitconnected.com/micro-frontend-curry-506b98a4cfc0

* 小さくて持続可能なコード構造
* 独立したアプリケーション /チームによる効率的な開発環境とスピード
* よりスケーラブルな組織構造
* A / Bテストおよびビルドプロセスの高速化

※ https://medium.com/hepsiburadatech/hepsiburada-micro-frontend-d%C3%B6n%C3%BC%C5%9F%C3%BCm%C3%BC-4c2f26b8dcae 
 
* アプリケーションは自己完結型です。つまり、各アプリケーションは単一の責任しか持たないため、凝集度が高くなります。
* アプリケーションは独立して開発できます—開発者は自分の仕事に集中してビジネス価値を提供できます。他のチームとの技術的な同期は必要ありません。
* アプリケーションは独立してデプロイできます。アプリケーションをデプロイするときに自由に選択できるため、システムの他の部分に悪影響を与えることはありません。
* アプリケーションはさまざまなテクノロジーで実装できます。フロントエンドテクノロジーが急速に進化している世界では、今後2年間はレガシーと見なされない理想的なJSフレームワークを選択することは不可能です。既存のシステムを書き直すことなく、新しいフレームワークを使用してコードを記述できたら素晴らしいと思いませんか？マイクロフロントエンドを使用すると、多くのフレームワークを組み合わせることができます。追加の利点は、私たちが好きな、またはチームのスキルに合ったテクノロジを選択できることです。
※　https://blog.pragmatists.com/independent-micro-frontends-with-single-spa-library-a829012dc5be
 
# Cons

* 重複作業の発生

* マイクロフロントエンドは、独立したチームの自律性を向上させますが、相互接続されたチームには多くを提供しません。開発チームが小さすぎる、ドメインが相互に関連しすぎている、または受信作業が事業部門間で均等に分割されていない可能性があります。マイクロフロントエンドを使用しますが、チームにバインドされたサービスとドメインがないと、分散モノリスを構築してしまう可能性があります。アーキテクチャは薄く広がりますが、チームはそうではありません。
* フロントエンドにはすべて、より大きな機能の部分的な実装が含まれているため、個別にリリースすることはできません。
* マイクロフロントエンド間でリンクを発生させることができます。これらのリンクにより、各フロントエンドの独立性が低下し、各リリースに多くの依存関係が生じます。
* くの機能で複数のマイクロフロントエンドにまたがる変更が必要になりました。これらの分割により、各フロントエンドの独立性と自律性がなくなりました。
* 個別のアプリケーション、言語、フレームワーク間で状態を渡す必要があります。前後のワークフロー、分岐パス、ユーザーがキャンセルまたは終了できるさまざまな場所を考慮する必要があります
* イブラリを共有すること自体は問題ではありませんが、不適切な分割によって作成された任意の境界を回避するための包括的な場所として使用すると、問題が発生します。
* 検出可能性が低下した結果、一部の標準コンポーネントを共有できず、個別のフロントエンド間で実装が重複してしまいました。
* コンポーネント間の通信の構築は、実装と維持が困難であるだけでなく、コンポーネントの独立性を取り除きます。
* 横断的関心事への変更ですべてのマイクロフロントエンドを最新の状態に保つだけでは、テレメトリ、エラーロギング、パイプラインの構築に時間を費やしてしまいます
* 共有キャッシュがないと、各Webビューは独自のデータセットをプルダウンする必要があり、大量の重複呼び出しが発生しました。

※ https://medium.com/swlh/problems-with-micro-frontends-8a8fc32a7d58

* 異なるバージョンの異なるアプリケーションが同じ依存関係を持っています

※　https://medium.com/hacking-talent/two-years-of-micro-frontends-a-retrospective-522526f76df4

* コメントアプリケーションがReact 16.xおよびRedux 4.xを使用し、製品フィルターアプリケーションがReact 15.xおよびRedux 3.xを使用する場合、同じ依存関係がユーザーに何度もインストールされます

※ https://medium.com/hepsiburadatech/hepsiburada-micro-frontend-d%C3%B6n%C3%BC%C5%9F%C3%BCm%C3%BC-4c2f26b8dcae

* サイト全体のCSSスタイル
* サイト全体のCI / CDプロセス
* 別々のマイクロフロントエンドで作業する複数のチームは、互いに協力する必要があります。
* チームが独立して作業できない場合、それはモノリスアプリケーションのように聞こえます。

※ https://medium.com/bb-tutorials-and-thoughts/should-we-frameworks-for-micro-frontends-35f9f15b7821 

* マイクロサービスと同様に、追跡、デバッグ、追跡はモノリスよりもはるかに難しく、優れた戦略が必要です。
* マイクロフロントエンドは、操作が複雑でコストも高くなります。
* 多くのバージョンがあるので、バージョン管理への対応を検討する必要があります。
* プラグイン間でUI / UXの不整合を利用できます。
* マイクロフロントエンドの実装が不適切な場合、パフォーマンスが低下する可能性があります。
※ https://medium.com/@pyaesonenyein/micro-frontends-part-one-95ea3d939bc6 
